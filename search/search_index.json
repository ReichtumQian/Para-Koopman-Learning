{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This repo implements the EDMD algorithm, EDMDDL algorithm [1] and the learning of parametric Koopman decomposition [2].</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To set up the environment, please refer to  Set up the environment. This repository is designed to be user-friendly. You only need a few lines of code to run a simple example. For a quick start, please check out the  Quick Start. A few examples are provided in the <code>example</code> folder of this repository.</p>"},{"location":"#user-guide","title":"User Guide","text":"<ul> <li>Customizing Input Parameters and Solver:  Input Guide.</li> <li>Customizing Observable Functions:  Custom Observable Guide.</li> <li>Customizing ODE:  Custom ODE Guide.</li> <li>Customizing ODE Solver:  Custom ODE Solver Guide.</li> <li>Enhancing Performance with GPU and Multithreading:  Parallel Computing Guide.</li> </ul>"},{"location":"#class-references","title":"Class References","text":"<p>Most of the symbols in this documentation can be found at [2].</p> <ul> <li>Dictionary:  ObservableFunction,  Dictionary,  TrainableDictionary,  RBFDictionary.</li> <li>Koopman Operator:  Koopman,  ParamKoopman,  KoopmanDynamics.</li> <li>Solver:  EDMDSolver,  EDMDDLSolver,  ParamKoopmanDLSolver,  KoopmanDynamics.</li> <li>SolverWrapper:  SolverWrapper,  EDMDRBFSolverWrapper,  EDMDDLSolverWrapper,  ParamKoopmanDLSolverWrapper.</li> <li>ODEs:  AbstractODE,  DiscreteDynamics.</li> <li>ODE Solver:  ODESolver.</li> <li>Data Management:  KoopmanDataSet,  ParamKoopmanDataSet.</li> <li>Neural Network:  FullConnBaseNet,  FullConnNet,  FullConnResNet.</li> <li>Control Solver:  KoopmanMPCSolver.</li> </ul>"},{"location":"#references","title":"References","text":"<p>[1]: Li, Q., Dietrich, F., Bollt, E. M., &amp; Kevrekidis, I. G. (2017). Extended dynamic mode decomposition with dictionary learning: A data-driven adaptive spectral decomposition of the Koopman operator. Chaos: An Interdisciplinary Journal of Nonlinear Science, 27(10), 103111.</p> <p>[2]: Guo, Yue, Milan Korda, Ioannis G. Kevrekidis, and Qianxiao Li. \"Learning Parametric Koopman Decompositions for Prediction and Control.\" arXiv preprint arXiv:2310.01124 (2023).</p>"},{"location":"ClassReferences/AbstractODE/","title":"Class AbstractODE","text":"<p>The class <code>AbstractODE</code> is an abstract class for ordinary differential equations (ODEs) of the form</p> \\[ \\dot{\\mathbf{x}}(t) = \\mathbf{f} (\\mathbf{x}(t), \\mathbf{u}). \\] <p>Info</p> <p>Since the <code>rhs</code> function must accommodate both fixed parameters and variable parameters, it should be capable of handling inputs of the form  \\(\\mathbb{R}^{N \\times N_x} \\times \\mathbb{R}^{1 \\times N_u}\\) (fixed parameters) and \\(\\mathbb{R}^{N \\times N_x} \\times \\mathbb{R}^{N \\times N_u}\\) (variable parameters).</p>"},{"location":"ClassReferences/AbstractODE/#api-documentation","title":"API Documentation","text":""},{"location":"ClassReferences/AbstractODE/#PKoopmanDL.AbstractODE.dim","title":"<code>dim</code>  <code>property</code>","text":"<p>Returns the dimension of the system.</p> <p>Returns:</p> Type Description <code>int</code> <p>The dimension of the system.</p>"},{"location":"ClassReferences/AbstractODE/#PKoopmanDL.AbstractODE.param_dim","title":"<code>param_dim</code>  <code>property</code>","text":"<p>Returns the dimension of the parameters.</p> <p>Returns:</p> Type Description <code>int</code> <p>The dimension of the parameters.</p>"},{"location":"ClassReferences/AbstractODE/#PKoopmanDL.AbstractODE.__init__","title":"<code>__init__(dim, param_dim, rhs)</code>","text":"<p>Initializes the ODE class with the given dimensions and right-hand side function.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>The dimension of the system.</p> required <code>param_dim</code> <code>int</code> <p>The dimension of the parameter space.</p> required <code>rhs</code> <code>torch.Tensor -&gt; torch.Tensor</code> <p>The right-hand side function of the ODE, which defines the system dynamics.</p> required"},{"location":"ClassReferences/AbstractODE/#PKoopmanDL.AbstractODE.rhs","title":"<code>rhs(x, u)</code>","text":"<p>Compute the right-hand side of the differential equation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The state tensor.</p> required <code>u</code> <code>Tensor</code> <p>The parametric input tensor.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The computed right-hand side of the differential equation.</p>"},{"location":"ClassReferences/Dictionary/","title":"Class Dictionary","text":"<p>A <code>Dictionary</code> is a vector-valued function denoted as</p> \\[\\Psi = (\\psi_1, \\psi_2, \\cdots, \\psi_{N_\\psi})^T,\\] <p>where each component \\(\\psi_i = g_i\\) for \\(i = 1,\\cdots,N_y\\). The functions \\(g_{1},\\cdots, g_{N_{y}}\\) represent the target observable functions. It supports batched operation \\(\\Psi: \\mathbb{R}^{N \\times N_x} \\rightarrow \\mathbb{R}^{N \\times N_{\\psi}}\\).</p>"},{"location":"ClassReferences/Dictionary/#api-documentation","title":"API Documentation","text":""},{"location":"ClassReferences/Dictionary/#PKoopmanDL.Dictionary.dim_input","title":"<code>dim_input</code>  <code>property</code>","text":"<p>Input dimension.</p> <p>Returns:</p> Type Description <code>int</code> <p>The input dimension.</p>"},{"location":"ClassReferences/Dictionary/#PKoopmanDL.Dictionary.dim_output","title":"<code>dim_output</code>  <code>property</code>","text":"<p>Output dimension.</p> <p>Returns:</p> Type Description <code>int</code> <p>The output dimension.</p>"},{"location":"ClassReferences/Dictionary/#PKoopmanDL.Dictionary.__call__","title":"<code>__call__(x)</code>","text":"<p>Apply the dictionary to the input.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Input state of the size \\((N, N_x)\\)</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The basis functions of the size \\((N, N_\\psi)\\)</p>"},{"location":"ClassReferences/Dictionary/#PKoopmanDL.Dictionary.__init__","title":"<code>__init__(function, dim_input, dim_output)</code>","text":"<p>Dictionary \\(\\Psi\\).</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>torch.Tensor -&gt; torch.Tensor</code> <p>Dictionary basis function \\((N, N_x) \\rightarrow (N, N_{\\psi})\\)</p> required <code>dim_input</code> <code>int</code> <p>Input dimension \\(N_x\\).</p> required <code>dim_output</code> <code>int</code> <p>Output dimension \\(N_\\psi\\).</p> required"},{"location":"ClassReferences/DiscreteDynamics/","title":"Class DiscreteDynamics","text":""},{"location":"ClassReferences/DiscreteDynamics/#PKoopmanDL.DiscreteDynamics.dim","title":"<code>dim</code>  <code>property</code>","text":"<p>Returns the dimension of the system.</p> <p>Returns:</p> Type Description <code>int</code> <p>The dimension of the system.</p>"},{"location":"ClassReferences/DiscreteDynamics/#PKoopmanDL.DiscreteDynamics.param_dim","title":"<code>param_dim</code>  <code>property</code>","text":"<p>Returns the dimension of the parameters.</p> <p>Returns:</p> Type Description <code>int</code> <p>The dimension of the parameters.</p>"},{"location":"ClassReferences/DiscreteDynamics/#PKoopmanDL.DiscreteDynamics.__init__","title":"<code>__init__(trans_func, dim, param_dim=0)</code>","text":"<p>Initializes the dynamics object with a transition function,  state dimension, and optional parameter dimension.</p> <p>Parameters:</p> Name Type Description Default <code>trans_func</code> <code>torch.Tensor -&gt; torch.Tensor</code> <p>The transformation function that defines the dynamics.</p> required <code>dim</code> <code>int</code> <p>The dimension of the state space.</p> required <code>param_dim</code> <code>int</code> <p>The dimension of the parameter space.</p> <code>0</code>"},{"location":"ClassReferences/DiscreteDynamics/#PKoopmanDL.DiscreteDynamics.step","title":"<code>step(x, u)</code>","text":"<p>Advances the system dynamics by one time step using the given state and parameter/control input.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The current state of the system.</p> required <code>u</code> <code>Tensor</code> <p>The control input to be applied.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The next state of the system after applying the control input.</p>"},{"location":"ClassReferences/DiscreteDynamics/#PKoopmanDL.DiscreteDynamics.traj","title":"<code>traj(x0, u0, traj_len)</code>","text":"<p>Simulate trajectory of a dynamical system.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>Tensor</code> <p>The initial state of the system. Expected shape is (N, number of state).</p> required <code>u0</code> <code>Tensor or None</code> <p>The control input or parameter. If None, a zero tensor is used.              If time-independent, should have shape (1, number of control inputs).              If time-dependent, should have shape (traj_len - 1, number of control inputs).</p> required <code>traj_len</code> <code>int</code> <p>The length of the trajectory to simulate.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>A tensor containing the simulated trajectory. The shape is (N, traj_len, number of state).</p>"},{"location":"ClassReferences/EDMDDLSolver/","title":"Class EDMDDLSolver","text":"<p>The class <code>EDMDDLSolver</code> implements the EDMD-DL algorithm. It's a subclass of  EDMDSolver.</p>"},{"location":"ClassReferences/EDMDDLSolver/#api-documentation","title":"API Documentation","text":"<p>               Bases: <code>EDMDSolver</code></p>"},{"location":"ClassReferences/EDMDDLSolver/#PKoopmanDL.EDMDDLSolver.__init__","title":"<code>__init__(dictionary, reg, reg_final=0.01)</code>","text":"<p>Initialize the EDMDDLSolver instance.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>TrainableDictionary</code> <p>The dictionary used in the algorithm.</p> required <code>reg</code> <code>float</code> <p>The regularization parameter used in the algorithm.</p> required <code>reg_final</code> <code>float</code> <p>The final regularization parameter used in the algorithm.</p> <code>0.01</code>"},{"location":"ClassReferences/EDMDDLSolver/#PKoopmanDL.EDMDDLSolver.solve","title":"<code>solve(dataset_train, dataset_val, n_epochs, batch_size, tol=1e-08, lr=0.0001)</code>","text":"<p>Solves the Koopman operator learning problem using the provided training and validation datasets.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_train</code> <code>KoopmanDataset</code> <p>The training dataset containing input data and labels.</p> required <code>dataset_val</code> <code>KoopmanDataset</code> <p>The validation dataset containing input data and labels.</p> required <code>n_epochs</code> <code>int</code> <p>The number of epochs to train the model.</p> required <code>batch_size</code> <code>int</code> <p>The size of each batch for training and validation.</p> required <code>tol</code> <code>float</code> <p>The tolerance for early stopping based on training loss. Defaults to 1e-8.</p> <code>1e-08</code> <code>lr</code> <code>float</code> <p>The learning rate for the optimizer. Defaults to 1e-4.</p> <code>0.0001</code> <p>Returns:</p> Type Description <code>Koopman</code> <p>The learned Koopman operator.</p>"},{"location":"ClassReferences/EDMDDLSolverWrapper/","title":"Class EDMDDLSolverWrapper","text":""},{"location":"ClassReferences/EDMDDLSolverWrapper/#api-documentation","title":"API Documentation","text":"<p>               Bases: <code>SolverWrapper</code></p>"},{"location":"ClassReferences/EDMDDLSolverWrapper/#PKoopmanDL.EDMDDLSolverWrapper.__init__","title":"<code>__init__(config_file)</code>","text":"<p>Initializes the SolverWrapper instance.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>The path to the configuration file.</p> required <p>Attributes:</p> Name Type Description <code>_use_param_dataset</code> <code>bool</code> <p>A flag indicating whether to use a parameterized dataset.</p>"},{"location":"ClassReferences/EDMDDLSolverWrapper/#PKoopmanDL.EDMDDLSolverWrapper.solve","title":"<code>solve()</code>","text":"<p>Solves the problem using EDMDDL algorithm with the provided datasets.</p> <p>Returns:</p> Type Description <code>Koopman</code> <p>The result of the EDMDDL algorithm.</p>"},{"location":"ClassReferences/EDMDRBFSolverWrapper/","title":"Class EDMDRBFSolverWrapper","text":"<p>The class <code>EDMDRBFSolverWrapper</code> is a subclass of <code>SolverWrapper</code>, it's a wrapper for the EDMDSolver using RBF.</p>"},{"location":"ClassReferences/EDMDRBFSolverWrapper/#api-documentation","title":"API Documentation","text":"<p>               Bases: <code>SolverWrapper</code></p>"},{"location":"ClassReferences/EDMDRBFSolverWrapper/#PKoopmanDL.EDMDRBFSolverWrapper.__init__","title":"<code>__init__(config_file)</code>","text":"<p>Initializes the SolverWrapper instance.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>The path to the configuration file.</p> required <p>Attributes:</p> Name Type Description <code>_use_param_dataset</code> <code>bool</code> <p>A flag indicating whether to use a parameterized dataset.</p>"},{"location":"ClassReferences/EDMDRBFSolverWrapper/#PKoopmanDL.EDMDRBFSolverWrapper.solve","title":"<code>solve()</code>","text":"<p>Executes the EDMD-RBF method using the provided dataset.</p> <p>Returns:</p> Type Description <code>Koopman</code> <p>The result of EDMD method.</p>"},{"location":"ClassReferences/EDMDSolver/","title":"Class EDMDSolver","text":"<p>The class <code>EDMDSolver</code> implements the EDMD algorithm.</p>"},{"location":"ClassReferences/EDMDSolver/#api-documentation","title":"API Documentation","text":""},{"location":"ClassReferences/EDMDSolver/#PKoopmanDL.EDMDSolver.__init__","title":"<code>__init__(dictionary)</code>","text":"<p>Initialize the EDMDSolver instance.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>Dictionary</code> <p>The dictionary used in the algorithm.</p> required"},{"location":"ClassReferences/EDMDSolver/#PKoopmanDL.EDMDSolver.solve","title":"<code>solve(dataset)</code>","text":"<p>Applies the EDMD algorithm to compute the Koopman operator.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>KoopmanDataSet</code> <p>The dataset containing state and label data.</p> required <p>Returns:</p> Type Description <code>Koopman</code> <p>The Koopman operator as a linear mapping function.</p>"},{"location":"ClassReferences/ForwardEuler/","title":"ForwardEuler","text":"<p>The class <code>ForwardEuler</code> is a subclass of ODESolver. It implements the forward Euler method</p> \\[ \\mathbf{x}(n+1) = \\mathbf{x}(n) + k \\mathbf{f}(\\mathbf{x}(n), \\mathbf{u}(n)), \\] <p>where \\(k\\) is the time step size.</p>"},{"location":"ClassReferences/FullConnBaseNet/","title":"Class FullConnBaseNet","text":"<p>The class <code>FullConnBaseNet</code> is a subclass of <code>torch.nn.Module</code>. It implements a basic structure of fully-connected network without the <code>forward</code> method.</p>"},{"location":"ClassReferences/FullConnBaseNet/#api-documentation","title":"API Documentation","text":"<p>               Bases: <code>Module</code></p>"},{"location":"ClassReferences/FullConnBaseNet/#PKoopmanDL.FullConnBaseNet.__init__","title":"<code>__init__(input_dim=1, output_dim=1, layer_size=[64, 64], activation='tanh', normalize_input=False)</code>","text":"<p>Initialize the FullConnResNet instance.</p> <p>Parameters:</p> Name Type Description Default <code>input_dim</code> <code>int</code> <p>The input dimension. Defaults to 1.</p> <code>1</code> <code>layer_size</code> <code>list</code> <p>The list of layer sizes. Defaults to [64, 64].</p> <code>[64, 64]</code> <code>output_dim</code> <code>int</code> <p>The output dimension. Defaults to 1.</p> <code>1</code> <code>activation</code> <code>str</code> <p>The activation function. Defaults to 'tanh'.</p> <code>'tanh'</code>"},{"location":"ClassReferences/FullConnBaseNet/#PKoopmanDL.FullConnBaseNet.forward","title":"<code>forward(inputs)</code>","text":"<p>Apply the network to the input <code>inputs</code></p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>tensor</code> <p>The input \\(\\mathbb{R}^{N \\times N_x}\\).</p> required <p>Returns:</p> Type Description <code>tensor</code> <p>The output \\(\\mathbb{R}^{N \\times N_y}\\).</p>"},{"location":"ClassReferences/FullConnNet/","title":"Class FullConnNet","text":"<p>The class <code>FullConnNet</code> is a subclass of  FullConnBaseNet. It is a fully connected neural network.</p>"},{"location":"ClassReferences/FullConnNet/#api-documentation","title":"API Documentation","text":"<p>               Bases: <code>FullConnBaseNet</code></p>"},{"location":"ClassReferences/FullConnNet/#PKoopmanDL.FullConnNet.forward","title":"<code>forward(inputs)</code>","text":"<p>Perform a forward pass through the network.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Tensor</code> <p>The input data to be processed by the network.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The output of the network after processing the input through the layers.</p>"},{"location":"ClassReferences/FullConnResNet/","title":"Class FullConnResNet","text":"<p>The class <code>FullConnResNet</code> is a subclass of  FullConnBaseNet. It represents a fully connected residual neural network.</p>"},{"location":"ClassReferences/FullConnResNet/#api-documentation","title":"API Documentation","text":"<p>               Bases: <code>FullConnBaseNet</code></p>"},{"location":"ClassReferences/FullConnResNet/#PKoopmanDL.FullConnResNet.forward","title":"<code>forward(inputs)</code>","text":"<p>Apply the network to the input <code>inputs</code></p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Tensor</code> <p>The input \\(\\mathbb{R}^{N \\times N_x}\\).</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The output \\(\\mathbb{R}^{N \\times N_y}\\).</p>"},{"location":"ClassReferences/Koopman/","title":"Class Koopman","text":"<p>The class <code>Koopman</code> is a mapping \\(K: \\mathrm{span}(\\Psi) \\rightarrow \\mathrm{span}(\\Psi)\\), which acts as the finite-dimensional approximation of the Koopman operator \\(\\mathcal{K}\\), i.e.,</p> \\[ \\mathcal{K} \\Psi \\approx K \\Psi. \\] <p>Given \\(\\phi = \\mathbf{a}^T \\Psi\\), where \\(\\mathbf{a} \\in \\mathbb{R}^{N_{\\psi}}\\), then the application of \\(\\mathcal{K}\\) satisfies</p> \\[ \\mathcal{K} \\phi = \\mathcal{K} \\mathbf{a}^T \\Psi \\approx \\mathbf{a}^T K \\Psi. \\] <p>Info</p> <p>Understanding the <code>__call__</code> method of <code>Koopman</code>: Given the data set \\(\\{x^{(n)}\\}_{n = 1}^N\\), it represents a mapping:</p> \\[ \\left[   \\begin{array}{cccc}     \\psi_1(x^{(1)})&amp;\\psi_2(x^{(1)})&amp;\\cdots&amp;\\psi_{N_{\\psi}}(x^{(1)})\\\\     \\psi_1(x^{(2)})&amp;\\psi_2(x^{(2)})&amp;\\cdots&amp;\\psi_{N_{\\psi}}(x^{(2)})\\\\     \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\     \\psi_1(x^{(N)})&amp;\\psi_2(x^{(N)})&amp;\\cdots&amp;\\psi_{N_{\\psi}}(x^{(N)})\\\\   \\end{array} \\right] \\rightarrow \\left[   \\begin{array}{cccc}     \\mathcal{K}\\psi_1(x^{(1)})&amp;\\mathcal{K}\\psi_2(x^{(1)})&amp;\\cdots&amp;\\mathcal{K}\\psi_{N_{\\psi}}(x^{(1)})\\\\     \\mathcal{K}\\psi_1(x^{(2)})&amp;\\mathcal{K}\\psi_2(x^{(2)})&amp;\\cdots&amp;\\mathcal{K}\\psi_{N_{\\psi}}(x^{(2)})\\\\     \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\     \\mathcal{K}\\psi_1(x^{(N)})&amp;\\mathcal{K}\\psi_2(x^{(N)})&amp;\\cdots&amp;\\mathcal{K}\\psi_{N_{\\psi}}(x^{(N)})\\\\   \\end{array} \\right]\\]"},{"location":"ClassReferences/Koopman/#api-documentation","title":"API Documentation","text":""},{"location":"ClassReferences/Koopman/#PKoopmanDL.Koopman.__call__","title":"<code>__call__(x, u)</code>","text":"<p>Apply the Koopman operator \\(K(x)\\), here the input \\(u\\) is ignored.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The input dictionary basis of the size \\((N, N_{\\psi})\\).</p> required <code>u</code> <code>Tensor</code> <p>Ignored</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Applied the Koopman operator, it's of the size \\((N, N_{\\psi})\\).</p>"},{"location":"ClassReferences/Koopman/#PKoopmanDL.Koopman.__init__","title":"<code>__init__(K)</code>","text":"<p>Initialize the Koopman instance.</p> <p>Parameters:</p> Name Type Description Default <code>K</code> <code>Tensor</code> <p>The Koopman matrix of the size \\((N_{\\psi}, N_{\\psi})\\)</p> required"},{"location":"ClassReferences/Koopman/#PKoopmanDL.Koopman.load","title":"<code>load(path)</code>","text":"<p>Load the Koopman operator from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the Koopman operator.</p> required"},{"location":"ClassReferences/Koopman/#PKoopmanDL.Koopman.save","title":"<code>save(path)</code>","text":"<p>Save the Koopman operator to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the Koopman operator.</p> required"},{"location":"ClassReferences/Koopman/#PKoopmanDL.Koopman.step","title":"<code>step(x, u)</code>","text":"<p>Consider the Koopman operator as a step function \\Psi_{n+1} = K \\Psi_n.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The input dictionary basis of the size \\((N, N_{\\psi})\\).</p> required <code>u</code> <code>Tensor</code> <p>Ignored</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Applied the Koopman operator, it's of the size \\((N, N_{\\psi})\\).</p>"},{"location":"ClassReferences/KoopmanDataSet/","title":"Class KoopmanDataSet","text":"<p>The class <code>KoopmanDataSet</code> is a subclass of <code>torch.utils.data.Dataset</code>, it provides data for <code>EDMDSolver</code> and <code>EDMDDLSolver</code>.</p>"},{"location":"ClassReferences/KoopmanDataSet/#api-documentation","title":"API Documentation","text":"<p>               Bases: <code>Dataset</code></p>"},{"location":"ClassReferences/KoopmanDataSet/#PKoopmanDL.KoopmanDataSet.data_x","title":"<code>data_x</code>  <code>property</code>","text":"<p>Returns the generated data for the x component of the dataset.</p>"},{"location":"ClassReferences/KoopmanDataSet/#PKoopmanDL.KoopmanDataSet.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>Returns the labels of the dataset.</p>"},{"location":"ClassReferences/KoopmanDataSet/#PKoopmanDL.KoopmanDataSet.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Retrieve the data and label at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the data item to retrieve.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the data and its corresponding label at the specified index.</p>"},{"location":"ClassReferences/KoopmanDataSet/#PKoopmanDL.KoopmanDataSet.__init__","title":"<code>__init__(dynamics, x_sample_func=torch.rand)</code>","text":"<p>Initializes the KoopmanDataSet object.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>DiscreteDynamics</code> <p>An object representing the dynamics of the system.</p> required <code>x_sample_func</code> <code>callable</code> <p>A function to sample initial states. </p> <code>rand</code> <p>Attributes:</p> Name Type Description <code>_dynamics</code> <code>DiscreteDynamics</code> <p>Stores the dynamics of the system.</p> <code>_generated</code> <code>bool</code> <p>Indicates whether the dataset has been generated.</p> <code>_x_sample_func</code> <code>callable</code> <p>Function to sample initial states.</p>"},{"location":"ClassReferences/KoopmanDataSet/#PKoopmanDL.KoopmanDataSet.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of samples in the dataset.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of samples in the dataset.</p>"},{"location":"ClassReferences/KoopmanDataSet/#PKoopmanDL.KoopmanDataSet.generate_data","title":"<code>generate_data(n_traj, traj_len, x_min, x_max, param, seed_x=11)</code>","text":"<p>Generates a dataset of trajectories for a dynamical system.</p> <p>Parameters:</p> Name Type Description Default <code>n_traj</code> <code>int</code> <p>Number of trajectories to generate.</p> required <code>traj_len</code> <code>int</code> <p>Length of each trajectory.</p> required <code>x_min</code> <code>float or Tensor</code> <p>Minimum value(s) for initial state sampling.</p> required <code>x_max</code> <code>float or Tensor</code> <p>Maximum value(s) for initial state sampling.</p> required <code>param</code> <code>Tensor</code> <p>Parameters for the dynamics function.</p> required <code>seed_x</code> <code>int</code> <p>Random seed for initial state sampling. Defaults to 11.</p> <code>11</code> <p>Returns:</p> Type Description <code>None</code> <p>The generated data is stored in the instance variables <code>_data_x</code> and <code>_labels</code>.</p>"},{"location":"ClassReferences/KoopmanDataSet/#PKoopmanDL.KoopmanDataSet.load","title":"<code>load(file)</code>","text":"<p>Load data from a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The path to the pickle file containing the data to be loaded.</p> required"},{"location":"ClassReferences/KoopmanDataSet/#PKoopmanDL.KoopmanDataSet.save","title":"<code>save(file)</code>","text":"<p>Save the generated dataset to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The path to the file where the dataset will be saved.</p> required"},{"location":"ClassReferences/KoopmanDynamics/","title":"Class KoopmanDynamics","text":"<p>               Bases: <code>DiscreteDynamics</code></p> <p>Koopman Dynamics of the form \\(\\Psi_{n+1} = K \\Psi_n\\). The states are updated from the dictionary's output.</p>"},{"location":"ClassReferences/KoopmanDynamics/#PKoopmanDL.KoopmanDynamics.__init__","title":"<code>__init__(koopman, dictionary, state_pos, state_dim, param_dim=0)</code>","text":"<p>Initializes the Dynamics class with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>koopman</code> <code>Koopman or ParamKoopman</code> <p>An instance representing the Koopman operator.</p> required <code>dictionary</code> <code>Dictionary or TrainableDictionary</code> <p>A dictionary or function used for state transition.</p> required <code>state_pos</code> <code>list[int]</code> <p>The position or index of the state in the input data.</p> required <code>state_dim</code> <code>int</code> <p>The dimensionality of the state space.</p> required <code>param_dim</code> <code>int</code> <p>The dimensionality of the parameter space. Defaults to 0.</p> <code>0</code>"},{"location":"ClassReferences/KoopmanDynamics/#PKoopmanDL.KoopmanDynamics.step","title":"<code>step(x, u)</code>","text":"<p>Advances the system dynamics by one time step.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The current state of the system.</p> required <code>u</code> <code>Tensor</code> <p>The control input applied to the system.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The next state of the system after applying the control input.</p>"},{"location":"ClassReferences/KoopmanMPCSolver/","title":"Class KoopmanMPCSolver","text":"<p>Ths class <code>KoopmanMPCSolver</code> is used to solve the optimal control problem using Koopman operator and model predictive control (MPC).</p>"},{"location":"ClassReferences/KoopmanMPCSolver/#api-documentation","title":"API Documentation","text":""},{"location":"ClassReferences/KoopmanMPCSolver/#PKoopmanDL.KoopmanMPCSolver.__init__","title":"<code>__init__(dynamics, koopman, dictionary, ref_traj, time_horizon, observable_pos, lambda_param)</code>","text":"<p>Initializes an instance of the KoopmanMPCSolver class.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>KoopmanDynamics</code> <p>The Koopman dynamics system.</p> required <code>koopman</code> <code>ParamKoopman</code> <p>The parametric Koopman operator.</p> required <code>dictionary</code> <code>TrainableDictionary or Dictionary</code> <p>A function that maps the state to the dictionary of observables.</p> required <code>ref_traj</code> <code>Tensor</code> <p>A tensor containing the reference trajectory, with shape (trajectory_length, state_dimension).</p> required <code>time_horizon</code> <code>int</code> <p>The time horizon for model predictive control.</p> required <code>observable_pos</code> <code>int</code> <p>The position(s) of target observables in dictionary.</p> required <code>lambda_param</code> <code>float</code> <p>A regularization parameter used to balance the control error and tracking error.</p> required"},{"location":"ClassReferences/KoopmanMPCSolver/#PKoopmanDL.KoopmanMPCSolver.solve","title":"<code>solve(state0, control_min, control_max, method='powell', disp=False)</code>","text":"<p>Solve the optimal control problem for a given initial state and control bounds. Args:     state0 (torch.Tensor): The initial state of the system.     control_min (float or list of floats): Minimum allowable value(s) for the control input(s).     control_max (float or list of floats): Maximum allowable value(s) for the control input(s).     method (str, optional): Optimization method to use. Defaults to 'powell'.     disp (bool, optional): Whether to print convergence messages. Defaults to False.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>The optimal control sequence over the given time horizon.</p>"},{"location":"ClassReferences/ODESolver/","title":"Class ODESolver","text":"<p>The class <code>ODESolver</code> implements the flow map \\(\\varphi_t(x) := x(t), x(0) = x\\). This class serves as a base class for various numerical solvers for initial value problems (IVPs).</p>"},{"location":"ClassReferences/ODESolver/#api-documentation","title":"API Documentation","text":""},{"location":"ClassReferences/ODESolver/#PKoopmanDL.ODESolver.__init__","title":"<code>__init__(ode, t_step, dt=0.001)</code>","text":"<p>Initializes the ODESolver with the given ordinary differential equation (ODE), time step, and optional time increment.</p> <p>Parameters:</p> Name Type Description Default <code>ode</code> <code>AbstractODE</code> <p>The ordinary differential equation to be solved.</p> required <code>t_step</code> <code>float</code> <p>The time step for the solver.</p> required <code>dt</code> <code>float</code> <p>The time increment for each step. Defaults to 1e-3.</p> <code>0.001</code>"},{"location":"ClassReferences/ODESolver/#PKoopmanDL.ODESolver.step","title":"<code>step(x, u)</code>","text":"<p>Perform a single step of the ODE solver.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The current state of the system.</p> required <code>u</code> <code>Tensor</code> <p>The control input or parameters on the system.</p> required <p>Returns:</p> Type Description <code>NotImplementedError</code> <p>This method is intended to be overridden by subclasses to implement specific ODE solving logic.</p>"},{"location":"ClassReferences/ObservableFunction/","title":"Class ObservableFunction","text":"<p>The class <code>ObservableFunction</code> manages the observable functions of the system.</p>"},{"location":"ClassReferences/ObservableFunction/#api-documentation","title":"API Documentation","text":""},{"location":"ClassReferences/ObservableFunction/#PKoopmanDL.ObservableFunction.dim","title":"<code>dim</code>  <code>property</code>","text":"<p>The dimension of the output.</p> <p>Returns:</p> Type Description <code>int</code> <p>The dimension of the output.</p>"},{"location":"ClassReferences/ObservableFunction/#PKoopmanDL.ObservableFunction.__call__","title":"<code>__call__(x)</code>","text":"<p>Apply the observable functions to the input.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The input state of the size \\((N, N_x)\\)</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The output of the observable functions.</p>"},{"location":"ClassReferences/ObservableFunction/#PKoopmanDL.ObservableFunction.__init__","title":"<code>__init__(func, dim_output)</code>","text":"<p>Observable functions of the dynamical system.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>torch.Tensor -&gt; torch.Tensor</code> <p>Observable functions \\((N, N_x) \\rightarrow (N, N_g)\\)</p> required <code>dim_output</code> <code>int</code> <p>The dimension of the output \\(N_g\\).</p> required"},{"location":"ClassReferences/ParamKoopman/","title":"Class ParamKoopman","text":"<p>It represents a mapping \\(K: \\mathrm{span}(\\Psi) \\times U \\rightarrow \\mathrm{span}(\\Psi)\\), which is a finite-dimensional approximation of the parametric Koopman operator.</p>"},{"location":"ClassReferences/ParamKoopman/#api-documentation","title":"API Documentation","text":""},{"location":"ClassReferences/ParamKoopman/#PKoopmanDL.ParamKoopman.size","title":"<code>size</code>  <code>property</code>","text":"<p>Returns the size of the Koopman matrix.</p> <p>Returns:</p> Type Description <code>int</code> <p>The row/column size of the Koopman matrix.</p>"},{"location":"ClassReferences/ParamKoopman/#PKoopmanDL.ParamKoopman.__call__","title":"<code>__call__(x, u)</code>","text":"<p>Applies the Koopman operator to the input tensor <code>x</code> using the parameter tensor <code>u</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The input tensor of shape \\((N, N_\\psi)\\).</p> required <code>u</code> <code>Tensor</code> <p>The parameter tensor of shape \\((1, N_u)\\) or \\((N, N_u)\\). If <code>u</code> has a size of 1 in the first dimension,         it will be expanded to match the batch size of <code>x</code>.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The result of applying the Koopman operator, with the same batch size       as <code>x</code> and the transformed dimension.</p>"},{"location":"ClassReferences/ParamKoopman/#PKoopmanDL.ParamKoopman.__init__","title":"<code>__init__(size_K, network)</code>","text":"<p>Initialize the ParamKoopman instance.</p> <p>Parameters:</p> Name Type Description Default <code>size_K</code> <code>int</code> <p>The size of the Koopman matrix.</p> required <code>network</code> <code>Module</code> <p>The network to generate the Koopman operator.</p> required"},{"location":"ClassReferences/ParamKoopman/#PKoopmanDL.ParamKoopman.eval","title":"<code>eval()</code>","text":"<p>Sets the network to evaluation mode.</p>"},{"location":"ClassReferences/ParamKoopman/#PKoopmanDL.ParamKoopman.load","title":"<code>load(path)</code>","text":"<p>Loads the model state and size from a specified file path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path from which to load the model data.</p> required"},{"location":"ClassReferences/ParamKoopman/#PKoopmanDL.ParamKoopman.parameters","title":"<code>parameters()</code>","text":"<p>Retrieve the parameters of the network.</p> <p>Returns:</p> Type Description <code>Iterator[Parameter]</code> <p>An iterator over the parameters of the network.</p>"},{"location":"ClassReferences/ParamKoopman/#PKoopmanDL.ParamKoopman.save","title":"<code>save(path)</code>","text":"<p>Saves the current state of the network to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path where the state dictionary and size will be saved.</p> required"},{"location":"ClassReferences/ParamKoopman/#PKoopmanDL.ParamKoopman.step","title":"<code>step(x, u)</code>","text":"<p>Computes the next step in the system given the current state and parameter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The current state of the system.</p> required <code>u</code> <code>Tensor</code> <p>The control input to the system.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The next state of the system after applying the Koopman.</p>"},{"location":"ClassReferences/ParamKoopman/#PKoopmanDL.ParamKoopman.train","title":"<code>train()</code>","text":"<p>Sets the network to training mode.</p>"},{"location":"ClassReferences/ParamKoopmanDLSolver/","title":"Class ParamKoopmanDLSolver","text":"<p>The class <code>ParaKoopmanDLSolver</code> implements the algorithm of learning parametric Koopman decomposition.</p>"},{"location":"ClassReferences/ParamKoopmanDLSolver/#api-documentation","title":"API Documentation","text":""},{"location":"ClassReferences/ParamKoopmanDLSolver/#PKoopmanDL.ParamKoopmanDLSolver.__init__","title":"<code>__init__(dictionary)</code>","text":"<p>Initializes the KoopmanSolver with a given dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>TrainableDictionary</code> <p>A dictionary containing configuration or parameters for the Koopman solver.</p> required"},{"location":"ClassReferences/ParamKoopmanDLSolver/#PKoopmanDL.ParamKoopmanDLSolver.solve","title":"<code>solve(dataset_train, dataset_val, paramkoopman, n_epochs, batch_size, tol=1e-06, lr_dic=0.0001, lr_koop=0.0001, weight=None)</code>","text":"<p>Solves the ParamKoopmanDL problem using the provided datasets and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_train</code> <code>KoopmanDataset</code> <p>The training dataset.</p> required <code>dataset_val</code> <code>KoopmanDataset</code> <p>The validation dataset.</p> required <code>paramkoopman</code> <code>ParamKoopman</code> <p>The parameterized Koopman operator model.</p> required <code>n_epochs</code> <code>int</code> <p>The number of epochs to train the model.</p> required <code>batch_size</code> <code>int</code> <p>The batch size for training and validation.</p> required <code>tol</code> <code>float</code> <p>The tolerance for early stopping based on training loss. Default is 1e-6.</p> <code>1e-06</code> <code>lr_dic</code> <code>float</code> <p>The learning rate for the dictionary optimizer. Default is 1e-4.</p> <code>0.0001</code> <code>lr_koop</code> <code>float</code> <p>The learning rate for the Koopman optimizer. Default is 1e-4.</p> <code>0.0001</code> <p>Returns:</p> Type Description <code>ParamKoopman</code> <p>The trained parameterized Koopman operator model.</p>"},{"location":"ClassReferences/ParamKoopmanDLSolverWrapper/","title":"Class ParamKoopmanDLSolverWrapper","text":""},{"location":"ClassReferences/ParamKoopmanDLSolverWrapper/#api-documentation","title":"API Documentation","text":"<p>               Bases: <code>SolverWrapper</code></p>"},{"location":"ClassReferences/ParamKoopmanDLSolverWrapper/#PKoopmanDL.ParamKoopmanDLSolverWrapper.solve","title":"<code>solve(weight=None)</code>","text":"<p>Applies the parametric Koopman learning algorithm.</p> <p>Returns:</p> Type Description <code>ParamKoopman</code> <p>The result of the parametric Koopman learning algorithm.</p>"},{"location":"ClassReferences/ParamKoopmanDataSet/","title":"Class ParamKoopmanDataSet","text":"<p>The class <code>ParamKoopmanDataSet</code> is a subclass of <code>KoopmanDataSet</code>, it provides data for <code>ParamKoopmanDLSolver</code>.</p>"},{"location":"ClassReferences/ParamKoopmanDataSet/#api-documentation","title":"API Documentation","text":"<p>               Bases: <code>KoopmanDataSet</code></p>"},{"location":"ClassReferences/ParamKoopmanDataSet/#PKoopmanDL.ParamKoopmanDataSet.data_param","title":"<code>data_param</code>  <code>property</code>","text":"<p>Returns the parameters of the generated data.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>The parameters of the generated data.</p>"},{"location":"ClassReferences/ParamKoopmanDataSet/#PKoopmanDL.ParamKoopmanDataSet.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Retrieve the data and labels at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the data to retrieve.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the data, parameters, and labels at the specified index.</p>"},{"location":"ClassReferences/ParamKoopmanDataSet/#PKoopmanDL.ParamKoopmanDataSet.__init__","title":"<code>__init__(dynamics, x_sample_func=torch.rand, param_sample_func=torch.rand)</code>","text":"<p>Initializes the KoopmanDataSet class with the specified dynamics and sampling functions.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics</code> <code>DiscreteDynamics</code> <p>The dynamics function or model to be used in the dataset.</p> required <code>x_sample_func</code> <code>callable</code> <p>A function to sample the initial state <code>x</code>. Defaults to <code>torch.rand</code>.</p> <code>rand</code> <code>param_sample_func</code> <code>callable</code> <p>A function to sample the parameters. Defaults to <code>torch.rand</code>.</p> <code>rand</code>"},{"location":"ClassReferences/ParamKoopmanDataSet/#PKoopmanDL.ParamKoopmanDataSet.generate_data","title":"<code>generate_data(n_traj, n_traj_per_param, traj_len, x_min, x_max, param_min, param_max, seed_x=11, seed_param=22, param_time_dependent=False)</code>","text":"<p>Generates synthetic data for the ParamKoopmanDataSet.</p> <p>Parameters:</p> Name Type Description Default <code>n_traj</code> <code>int</code> <p>Number of trajectories to generate.</p> required <code>n_traj_per_param</code> <code>int</code> <p>Number of trajectories per parameter setting.</p> required <code>traj_len</code> <code>int</code> <p>Length of each trajectory.</p> required <code>x_min</code> <code>float or Tensor</code> <p>Minimum value for initial state sampling.</p> required <code>x_max</code> <code>float or Tensor</code> <p>Maximum value for initial state sampling.</p> required <code>param_min</code> <code>float or Tensor</code> <p>Minimum value for parameter sampling.</p> required <code>param_max</code> <code>float or Tensor</code> <p>Maximum value for parameter sampling.</p> required <code>seed_x</code> <code>int</code> <p>Random seed for initial state sampling. Default is 11.</p> <code>11</code> <code>seed_param</code> <code>int</code> <p>Random seed for parameter sampling. Default is 22.</p> <code>22</code> <code>param_time_dependent</code> <code>bool</code> <p>If True, parameters are time-dependent. Default is False.</p> <code>False</code> <p>Returns:   None: The generated data is stored in the instance variables _data_x, _data_param, and _labels.</p>"},{"location":"ClassReferences/ParamKoopmanDataSet/#PKoopmanDL.ParamKoopmanDataSet.load","title":"<code>load(file)</code>","text":"<p>Load data from a pickle file and set the object's attributes.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The path to the pickle file to be loaded.</p> required"},{"location":"ClassReferences/ParamKoopmanDataSet/#PKoopmanDL.ParamKoopmanDataSet.save","title":"<code>save(file)</code>","text":"<p>Saves the generated dataset to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The path to the file where the dataset will be saved.</p> required"},{"location":"ClassReferences/RBFDictionary/","title":"Class RBFDictionary","text":"<p>The class <code>RBFDictionary</code> is the implementation of the RBF dictionary, it's a subclass of  Dictionary.</p>"},{"location":"ClassReferences/RBFDictionary/#api-documentation","title":"API Documentation","text":"<p>               Bases: <code>Dictionary</code></p>"},{"location":"ClassReferences/RBFDictionary/#PKoopmanDL.RBFDictionary.__init__","title":"<code>__init__(data_x, observable_func, dim_input, dim_output, reg)</code>","text":"<p>Initialize the RBF dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data_x</code> <code>Tensor</code> <p>The data to initialize the RBF dictionary.</p> required <code>observable_func</code> <code>ObservableFunction</code> <p>The observable functions.</p> required <code>dim_input</code> <code>int</code> <p>Input dimension \\(N_x\\).</p> required <code>dim_output</code> <code>int</code> <p>Output dimension \\(N_\\psi\\).</p> required <code>reg</code> <code>float</code> <p>The regularization parameter.</p> required"},{"location":"ClassReferences/SolverWrapper/","title":"Class SolverWrapper","text":"<p>The class <code>SolverWrapper</code> is a wrapper for each solver, it offers a common interface for reading the config file, setting up the solver and solving the problem.</p>"},{"location":"ClassReferences/SolverWrapper/#api-documentation","title":"API Documentation","text":""},{"location":"ClassReferences/SolverWrapper/#PKoopmanDL.SolverWrapper.__init__","title":"<code>__init__(config_file)</code>","text":"<p>Initializes the SolverWrapper instance by loading configuration data from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>The path to the configuration file in JSON format.</p> required <p>This method performs the following actions:</p> <ul> <li>Loads the configuration data from the specified JSON file.</li> <li>Calls internal methods to read and process various configuration sections:</li> <li>ODE configuration</li> <li>ODE solver configuration</li> <li>Dataset configuration</li> <li>Dictionary configuration</li> <li>Solver configuration</li> </ul>"},{"location":"ClassReferences/SolverWrapper/#PKoopmanDL.SolverWrapper.setup","title":"<code>setup(observable_func, x_sample_func=torch.rand, param_sample_func=torch.rand)</code>","text":"<p>Initializes the solver setup by configuring the ODE, dataset, and dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>observable_func</code> <code>torch.Tensor -&gt; torch.Tensor</code> <p>A function that defines the observables for the system.</p> required <code>x_sample_func</code> <code>callable</code> <p>A function to sample initial conditions. Defaults to torch.rand.</p> <code>rand</code> <code>param_sample_func</code> <code>callable</code> <p>A function to sample parameters. Defaults to torch.rand.</p> <code>rand</code> <p>This method performs the following initializations:</p> <ul> <li>Initializes the ordinary differential equation (ODE).</li> <li>Sets up the ODE solver.</li> <li>Initializes the dataset using the provided sampling functions.</li> <li>Configures the dictionary with the given observable function.</li> <li>Prepares the solver for execution.</li> </ul>"},{"location":"ClassReferences/SolverWrapper/#PKoopmanDL.SolverWrapper.solve","title":"<code>solve()</code>","text":"<p>Placeholder method for solving a problem or executing a specific task.</p> <p>This method is intended to be overridden by subclasses to provide a concrete implementation of the solving logic. By default, it raises a NotImplementedError to indicate that the method has not been implemented.</p> <p>Returns:</p> Type Description <code>NotImplementedError</code> <p>Indicates that the method needs to be implemented in a subclass.</p>"},{"location":"ClassReferences/TrainableDictionary/","title":"Class TrainableDictionary","text":"<p>The <code>TrainableDictionary</code> class is a subclass of Dictionary class. It contains a trainable neural network and a set of \\(N_y\\) non-trainable observable functions  (see ObservableFunction). The dictionary can be represented by the mapping \\(\\Psi: \\mathbb{R}^{N \\times N_x} \\rightarrow \\mathbb{R}^{N \\times N_{\\psi}}\\).</p>"},{"location":"ClassReferences/TrainableDictionary/#api-documentation","title":"API Documentation","text":"<p>               Bases: <code>Dictionary</code></p>"},{"location":"ClassReferences/TrainableDictionary/#PKoopmanDL.TrainableDictionary.__init__","title":"<code>__init__(network, observable_func, dim_input, dim_output)</code>","text":"<p>A trainable dictionary</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>Module</code> <p>The trainable network.</p> required <code>observable_func</code> <code>torch.Tensor -&gt; torch.Tensor</code> <p>Observable functions \\((N, N_x) \\rightarrow (N, N_{\\psi})\\)</p> required <code>dim_input</code> <code>int</code> <p>Input dimension \\(N_x\\).</p> required <code>dim_output</code> <code>int</code> <p>Output dimension \\(N_\\psi\\).</p> required Notes <p>The constant observable function \\(\\mathbf{1}\\) is included in the <code>TrainableDictionary</code> by default, so users don't need to define it explicitly.</p>"},{"location":"ClassReferences/TrainableDictionary/#PKoopmanDL.TrainableDictionary.eval","title":"<code>eval()</code>","text":"<p>Set the network to evaluation mode.</p>"},{"location":"ClassReferences/TrainableDictionary/#PKoopmanDL.TrainableDictionary.load","title":"<code>load(path)</code>","text":"<p>Load the network from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the network.</p> required"},{"location":"ClassReferences/TrainableDictionary/#PKoopmanDL.TrainableDictionary.parameters","title":"<code>parameters()</code>","text":"<p>Return the parameters of the network.</p> <p>Returns:</p> Type Description <code>Iterator[Parameter]</code> <p>The parameters of the network.</p>"},{"location":"ClassReferences/TrainableDictionary/#PKoopmanDL.TrainableDictionary.save","title":"<code>save(path)</code>","text":"<p>Save the network to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the network.</p> required"},{"location":"ClassReferences/TrainableDictionary/#PKoopmanDL.TrainableDictionary.train","title":"<code>train()</code>","text":"<p>Set the network to training mode.</p>"},{"location":"UserGuide/CustomizeODE/","title":"Customize ODE","text":"<p>We use factory pattern to manage ODEs. To customize an ODE, you can create a new class that inherits from the  Abstract class and then register it. Here's an example:</p> <pre><code>import PKoopmanDL as pkdl\n\nclass MyODE(pkdl.AbstractODE):\n  def rhs(self, x, u):\n    dim = 2 # state dim\n    param_dim = 2 # parameter dim\n\n    def func():\n      return x + u\n\n    super().__init__(dim, param_dim, func)\n\n# Register the ODE\npkdl.register_ode('MyODE', MyODE)\n</code></pre> <p>Once registered, you can use the custom ODE  in the same way as the built-in ODEs by specifying <code>\"MyODE\"</code> in your configuration JSON file.</p>"},{"location":"UserGuide/CustomizeODESolver/","title":"Customize ODE Solver","text":"<p>We use factory pattern to manage ODE solvers. To customize an ODE solver,  you can create a new class that inherits from the  ODESolver class and then register it. Your class must override the <code>step</code> method. Here's an example:</p> <pre><code>import PKoopmanDL as pkdl\n\nclass MyODESolver(pkdl.ODESolver):\n  def step(self, x, u):\n    n_step = int(self._t_step / self._dt)\n    for _ in range(n_step):\n      x = x + self._dt * self._ode.rhs(x, u)\n    return x\n\n# Register the ODE\npkdl.register_ode_solver('MyODESolver', MyODESolver)\n</code></pre> <p>Once registered, you can use the custom ODE solver in the same way as the built-in ODEs by specifying <code>\"MyODESolver\"</code> in your configuration JSON file.</p>"},{"location":"UserGuide/CustomizeObservable/","title":"Customize Observables","text":"<p>We use the  ObservableFunction class to manage observable functions. To create an observable function, you can simply provide a function that accepts a state and returns the observable targets, along with its output dimension. For example, a full-state observable function can be defined as follows:</p> <pre><code>tmp_func = lambda x: x\nobservable_func = pkdl.ObservableFunction(tmp_func, 2)\n</code></pre>"},{"location":"UserGuide/InputGuide/","title":"Input Guide","text":"<p>We explain in detail the parameters listed in the JSON files in <code>example/simple examples</code>.</p>"},{"location":"UserGuide/InputGuide/#general-parameters","title":"General Parameters","text":"<ul> <li><code>equ_type (string)</code>: Indicates the type of equation.    This type must be registered in the <code>ODEFACTORY</code>, see  Customize ODE for more details.</li> <li><code>ode_solver</code>:<ul> <li><code>type (string)</code>: Indicates the type of ODE solver.   This type must be registered in the <code>ODESOLVERFACTORY</code>, see  Customize ODE Solver for more details.</li> <li><code>dt (float)</code>: Time step \\(k\\) of the ODE Solver.</li> <li><code>t_step (float)</code>: Time step of the trajectories.</li> </ul> </li> <li><code>dataset</code>:<ul> <li><code>n_traj (int)</code>: Number of trajectories.</li> <li><code>traj_len (int)</code>: Length of each trajectory.</li> <li><code>x_min/x_max (float or list)</code>: Range of the states.   If a <code>float</code> is given, it means every state has the same range.</li> <li><code>seed_x (int)</code>: Seed for generating the states.</li> </ul> </li> <li><code>dictionary</code>:<ul> <li><code>dim_output (int)</code>: Output dimension \\(N_{\\Psi}\\) of the dictionary.</li> </ul> </li> </ul>"},{"location":"UserGuide/InputGuide/#edmd-rbf-algorithm","title":"EDMD-RBF Algorithm","text":"<ul> <li><code>dataset</code>:<ul> <li><code>param (list)</code>: Fixed parameters \\(u\\) of the dataset.</li> </ul> </li> <li><code>dictionary</code>:<ul> <li><code>reg (float)</code>: Regularization parameter \\(\\lambda\\) for generating the RBF functions.    </li> </ul> </li> </ul>"},{"location":"UserGuide/InputGuide/#edmddl-algorithm","title":"EDMDDL Algorithm","text":"<ul> <li><code>dataset</code>:<ul> <li><code>param (list)</code>: Fixed parameters \\(u\\) of the dataset.</li> <li><code>train_ratio (float)</code>: Ratio of the training set.</li> </ul> </li> <li><code>dictionary</code><ul> <li><code>dic_layer_sizes (list)</code>: Hidden layer sizes of the dictionary.</li> </ul> </li> <li><code>solver</code>:<ul> <li><code>reg (float)</code>: Regularization parameter \\(\\lambda\\) when training the Koopman operator.</li> <li><code>reg_final (float)</code>: Regularization parameter \\(\\lambda\\) when outputting the Koopman operator.</li> <li><code>n_epochs (int)</code>: Number of training epochs.</li> <li><code>batch_size (int)</code>: Batch size for training.</li> <li><code>tol (float)</code>: Tolerance of training.</li> <li><code>dic_lr (float)</code>: Learning rate for training the dictionary.</li> </ul> </li> </ul>"},{"location":"UserGuide/InputGuide/#parametric-koopman-learning","title":"Parametric Koopman Learning","text":"<ul> <li><code>dataset</code><ul> <li><code>n_traj_per_param (int)</code>: Number of trajectories per parameter setting.</li> <li><code>param_min/param_max (list)</code>: Range of the parameters.</li> <li><code>seed_param (int)</code>: Seed for generating the parameters.</li> <li><code>param_time_dependent (bool)</code>: Indicates whether the parameters are time-dependent.</li> </ul> </li> <li><code>dictionary</code>:<ul> <li><code>dic_layer_sizes (list)</code>: Hidden layer sizes of the dictionary.</li> </ul> </li> <li><code>solver</code>:<ul> <li><code>n_epochs (int)</code>: Number of training epochs.</li> <li><code>batch_size (int)</code>: Batch size for training.</li> <li><code>tol (float)</code>: Tolerance of training.</li> <li><code>dic_lr (float)</code>: Learning rate for training the dictionary.</li> <li><code>koopman_layer_sizes (list)</code>: Hidden layer sizes for the Koopman operator.</li> <li><code>koopman_lr (float)</code>: Learning rate for training the Koopman operator.</li> </ul> </li> </ul>"},{"location":"UserGuide/Parallel/","title":"Parallel Computing","text":"<p>This repository supports parallel computing through <code>CUDA</code>  and \"multi-threading\" using the joblib library.</p>"},{"location":"UserGuide/Parallel/#using-multi-threading","title":"Using Multi-threading","text":"<p>We utilize <code>joblib</code> to take advantage of multiple cores of the CPU, primarily used to accelerate the process of solving ODEs with <code>Scipy</code>. To set or get the number of threads, use the following code:</p> <pre><code>import PKoopmanDL\n\n# get the number of threads\nn_jobs = PKoopmanDL.get_n_jobs()\n\n# set the number of threads\nPKoopmanDL.set_n_jobs(n_jobs)\n\n# use all available cores\nPKoopmanDL.set_n_jobs(-1) \n</code></pre>"},{"location":"UserGuide/Parallel/#using-cuda","title":"Using CUDA","text":"<p>CUDA is employed to accelerate neural network training, supported by <code>pytorch</code>. We use <code>torch.cuda</code> to manage the GPU resources. You can use <code>PKoopmanDL.print_device()</code> to check the current device.</p>"},{"location":"UserGuide/QuickStart/","title":"Quick Start","text":"<p>We strongly encourage you to look through the examples in <code>example/simple examples</code> directory.  We provide three simple examples using the EDMD algorithm, the EDMDDL algorithm and the parametric Koopman learning algorithm.</p> <p>Each example consists of a JSON file and a jupyter notebook.  Let's consider the parametric Koopman learning algorithm as an example.</p>"},{"location":"UserGuide/QuickStart/#training-the-parametric-koopman-operator","title":"Training the Parametric Koopman Operator","text":"<p>As written in the notebook, the training process contains the following lines:</p> <pre><code>import PKoopmanDL as pkdl\n\nconfig_file = \"ParamKoopman.json\"\ntmp_func = lambda x: x\nobservable_func = pkdl.ObservableFunction(tmp_func, 2)\nsolver = pkdl.ParamKoopmanDLSolverWrapper(config_file)\nsolver.setup(observable_func)\nK = solver.solve()\n</code></pre> <ul> <li><code>config_file</code>: Specifies the JSON input file containing configuration parameters.</li> <li><code>observable_func</code>: Defines the observable functions and their output dim.   In this example, we use a full-state observable function.</li> <li><code>ParamKoopmanSolverWrapper</code>: Takes the configuration file and setup the solver automatically.</li> <li><code>K</code>: Represents the learned parametric Koopman operator.</li> </ul> <p>More information about the input files and the solvers can be found at  Input Guide.</p>"},{"location":"UserGuide/QuickStart/#generating-the-trajectories","title":"Generating the Trajectories","text":"<p>In our package, we treat the Koopman operator as a specialized transition function. Specifically, a <code>Dictionary</code> combined with a <code>Koopman</code> operator forms a discrete dynamical system:</p> \\[ \\Psi_{n+1} = \\mathcal{K} \\Psi_n. \\] <p>A potentially tricky aspect is that when the full-state observable functions are included in the dictionary, the Koopman operator can be used to predict the state through the sequence</p> \\[ x_n \\rightarrow \\Psi_n \\xrightarrow{\\mathcal{K}} \\Psi_{n+1} \\rightarrow x_{n+1}. \\] <p>To facilitate this process, we have designed a dedicated class  KoopmanDynamics. This class is designed to predict state trajectories  starting from an initial state <code>x0</code>. To use it,  simply create a <code>KoopmanDynamics</code> and call its <code>traj</code> method:</p> <pre><code>state_pos = [0, 1] # the position of the state in the observable function\nstate_dim = 2\nkoopman_dynamics = pkdl.KoopmanDynamics(K, solver.dictionary, state_pos, state_dim)\n# the output is of the form (N, traj_len, number of state),\n# where N is the number of different initial states\np = koopman_dynamics.traj(x0, param, solver.traj_len)\n</code></pre>"},{"location":"UserGuide/Setup/","title":"Set up the Environment","text":"<p>You can follow these steps to set up an environment that uses the CPU:</p> <pre><code>git clone https://github.com/ReichtumQian/ParamKoopmanDL.git\ncd ParamKoopmanDL\n\n# (optional) Create a new environment\nconda create -n KoopmanDL\nconda activate KoopmanDL\n\n# By default using CPU\npip install -r requirements.txt\npip install .\n</code></pre>"}]}